#!/usr/bin/env python3

import argparse, json, re, os
from langtag import langtag, LangTags, LangTag
import xml.etree.ElementTree as et
from functools import reduce

def matchtag(tagset, tag):
    if tagset is not None:
        regions = [tagset['region']] + tagset.get('regions', [])
        rtest = tag.get('region', None)
        if rtest:
            res = list(set(regions) & set(rtest))
        else:
            res = ["*"]
    else:
        res = tag.get('region', [])
    rscript = tag.get('script', None)
    if rscript and (tagset is None or tagset['script'] not in rscript):
        res = []
    rlang = tag.get('lang', None)
    if rlang:
        if tagset is None:
            res = []
        else:
            lt = langtag(tagset.get('full', tagset.get('tag', None)))
            if lt.lang not in rlang:
                res = []
    return res if res else None

def match(tagset, rule):
    for t in rule['tags']:
        res = matchtag(tagset, t)
        if res:
            return res
    return None

def mergelines(m):
    return "[" + " ".join(x.strip() for x in m.group(1).split("\n")) + "]"

def addfallback(tset, key, regions, used, msater, lts):
    l = lts.get(key, default=None)
    if l is not None and str(l.tag) == tset['tag']:
        return
    elif l is not None:
        key = str(l.tag)
    for r in regions:
        if r in used or r in master.get(key, set()):
            continue
        t.setdefault('fallback', {}).setdefault(key, set()).add(r)
        used.add(r)


parser = argparse.ArgumentParser()
parser.add_argument("infile",help="langtags.json")
parser.add_argument("fallback",help="fallback.json")
parser.add_argument("-o","--outfile",help="Output langtags.json")
parser.add_argument("-l","--likely",help="likelySubtags.xml to get und_ defaults")
parser.add_argument("-v","--verbose",action="store_true",help="verbose output")
args = parser.parse_args()

with open(args.infile, encoding="utf-8") as inf:
    ltags = json.load(inf)

with open(args.fallback, encoding="utf-8") as inf:
    frules = json.load(inf)

if args.likely is None:
    try:
        import sldr
        args.likely = os.path.join(os.path.dirname(sldr.__file__), 'likelySubtags.xml')
    except ImportError:
        args.likely = None

ldoc = None
if args.likely is not None:
    ldoc = et.parse(args.likely)

lts = LangTags(fname=args.infile)
master = {}
for r in frules['rules']:
    if len(r['tags']) > 1 or len(r['tags'][0]) > 1 or 'region' not in r['tags'][0]:
        continue
    master.setdefault(r['fallback'], set()).update(r['tags'][0]['region'])
fback = {"tag": "_fallbacks", "rules": {}}
for k, v in master.items():
    fback['rules'][k] = sorted(v)
ltags.insert(4, fback)

for t in ltags:
    if t.get('tag', "_").startswith("_"):
        continue
    used = set()
    for r in frules['rules']:
        if r.get('ignore', False) :
            continue
        regions = match(t, r)
        if regions:
            addfallback(t, r['fallback'], regions, used, master, lts)
    s = t.get("script", "")
    for r in [t['region']] + r.get('regions', []):
        for a in ("{}_{}".format(s, r), r, s):
            if not a or a.startswith("_") or a.endswith("_"):
                continue
            fb = ldoc.find('.//likelySubtag[@from="und_{}"]'.format(a))
            if fb is not None:
                lfb = lts.get(fb.get("to"), False)
                if lfb and r not in used:
                    addfallback(t, str(lfb.tag), [r], used, lts)
    for k, v in t.get('fallback', {}).items():
        t['fallback'][k] = sorted(v)

if args.outfile:
    output = json.dumps(sorted(ltags, key=lambda x:x['tag']), ensure_ascii=False, indent=4, sort_keys=True)
    output = "[" + re.sub(r'\[([^\]]+)\]', mergelines, output[1:-1]) + "]\n"
    with open(args.outfile, "w", encoding="utf-8") as outf:
        outf.write(output)

